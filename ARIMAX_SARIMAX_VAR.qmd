---
title: "ARIMAX_SARIMAX_VAR"
editor: visual
---

```{r, echo=FALSE,message=FALSE,warning=FALSE}
library(tidyverse)
library(ggplot2)
library(forecast)
library(astsa) 
library(xts)
library(tseries)
library(fpp2)
library(fma)
library(lubridate)
library(tidyverse)
library(TSstudio)
library(quantmod)
library(tidyquant)
library(plotly)
library(ggplot2)
library(vars)
library(astsa)
library(tidyverse)
library(fpp2)
library(forecast)
library(tseries)
library(ggplot2)
library(tidyverse)
library(xts)
library(fma)
library(lubridate)
library(TSstudio)
library(plotly)
```

# ARIMAX

```{r, echo=FALSE,message=FALSE,warning=FALSE}
macro <- read_csv('./data/macro_monthly.csv')
```

```{r, echo=FALSE,message=FALSE,warning=FALSE}
us_daily_birth_1 <- read_csv('./data/US_births_1994-2003_CDC_NCHS.csv')
us_daily_birth_2 <- read_csv('./data/US_births_2000-2014_SSA.csv')
us_daily_birth_1 <- us_daily_birth_1[1:2191,]
us_daily_birth <- rbind(us_daily_birth_1, us_daily_birth_2)
us_daily_birth$Date <- as.Date(paste(us_daily_birth$year, us_daily_birth$month, us_daily_birth$date_of_month, sep = "-"))
us_daily_birth <- data_frame(DATE=us_daily_birth$Date,Births=us_daily_birth$births)


macro <- read_csv('./data/macro_monthly.csv')
macro <- macro[,c('DATE','unrate','psr')]

dd <- merge(us_daily_birth, macro, by = "DATE")
```

## Plotting the Data

```{r}
dd.ts<-ts(dd,star=decimal_date(as.Date("1994-01-01",format = "%Y-%m-%d")),frequency = 12)

autoplot(dd.ts[,c(2:4)], facets=TRUE) +
  xlab("Year") + ylab("") +
  ggtitle("Variables influencing number of  birth in USA")
```

US Monthly Birth: The number of new births in each month from 1994 to 2014. We want to build a model to predict future number of new births. psr: PSR stands for Public Sector Revenue, which is an economic indicator that measures the total revenue generated by the public sector of an economy, including government agencies and state-owned enterprises. This revenue can come from various sources such as taxes, fees, and fines. PSR is often used as an important macroeconomic indicator to assess the fiscal health of a country or region. It is typically reported as a percentage of the Gross Domestic Product (GDP) to provide a measure of the government's ability to finance its activities and programs. unemployment rate: The unemployment rate is a measure of the percentage of the labor force that is currently unemployed but actively seeking employment and willing to work. It is a commonly used economic indicator that provides information on the health of the job market and can be used to gauge the overall health of the economy. The unemployment rate is calculated by dividing the number of unemployed individuals by the total number of individuals in the labor force, which includes both employed and unemployed individuals who are actively seeking employment.

Also this needs a log transformation.

```{r, echo=FALSE,message=FALSE,warning=FALSE}
lg.dd<-dd #making a copy
lg.dd$Births<-log(dd$Births);lg.dd$unrate<-log(dd$unrate);lg.dd$psr<-log(dd$psr)

lg.dd.ts<-ts(lg.dd,star=decimal_date(as.Date("1994-01-01",format = "%Y-%m-%d")),frequency = 12)

autoplot(lg.dd.ts[,c(2:4)], facets=TRUE) +
  xlab("Year") + ylab("") +
  ggtitle("Variables influencing Number of Birth in USA")
```

## Fitting the model using 'auto.arima()\`

Here I'm using auto.arima() function to fit the ARIMAX model. Here we are trying to predict Monthly number of birth using unemployment rate and psr. Remember all variables are time series and the exogenous variables in this case are unemployment rate and psr.

```{r, echo=FALSE,message=FALSE,warning=FALSE}
xreg <- cbind(unrate = dd.ts[, "unrate"],
              psr = dd.ts[, "psr"])

fit <- auto.arima(dd.ts[, "Births"], xreg = xreg)
summary(fit)
```

```{r, echo=FALSE,message=FALSE,warning=FALSE}
checkresiduals(fit)
```

## Fitting the model manually

Here we will first have to fit the linear regression model predicting monthly number of birth using unrate and psr.

Then for the residuals, we will fit an ARIMA/SARIMA model.

```{r, echo=FALSE,message=FALSE,warning=FALSE}
dd$Births<-ts(dd$Births,star=decimal_date(as.Date("1994-01-01",format = "%Y-%m-%d")),frequency = 12)
dd$unrate<-ts(dd$unrate,star=decimal_date(as.Date("1994-01-01",format = "%Y-%m-%d")),frequency = 12)
dd$psr<-ts(dd$psr,star=decimal_date(as.Date("1994-01-01",format = "%Y-%m-%d")),frequency = 12)

############# First fit the linear model##########
fit.reg <- lm(Births ~ unrate+psr, data=dd)
summary(fit.reg)
```

```{r, echo=FALSE,message=FALSE,warning=FALSE}
res.fit<-ts(residuals(fit.reg),star=decimal_date(as.Date("1994-01-01",format = "%Y-%m-%d")),frequency = 12)

############## Then look at the residuals ############
ggAcf(res.fit)
```

```{r, echo=FALSE,message=FALSE,warning=FALSE}
ggPacf(res.fit)
```

```{r, echo=FALSE,message=FALSE,warning=FALSE}
res.fit %>% diff() %>% ggtsdisplay()
```

```{r, echo=FALSE,message=FALSE,warning=FALSE}
res.fit %>% diff() %>% diff(12) %>% ggtsdisplay()
```

q=1,2,3 Q=1,2 , p=1,2, P=1,2

```{r, echo=FALSE,message=FALSE,warning=FALSE}
SARIMA.c=function(p1,p2,q1,q2,P1,P2,Q1,Q2,d1,d2,data){
  
  temp=c()
  d=1
  D=1
  s=12
  
  i=1
  temp= data.frame()
  ls=matrix(rep(NA,9*42),nrow=42)
  
  
  for (p in p1:p2)
  {
    for(q in q1:q2)
    {
      for(P in P1:P2)
      {
        for(Q in Q1:Q2)
        {
          for(d in d1:d2)
       
        {
          if(p+d+q+P+D+Q<=8)
          {
            
            model<- Arima(data,order=c(p-1,d,q-1),seasonal=c(P-1,D,Q-1))
            ls[i,]= c(p-1,d,q-1,P-1,D,Q-1,model$aic,model$bic,model$aicc)
            i=i+1
            #print(i)
            
          }
          
        }
      }
    }
    
  }
  
  }
  temp= as.data.frame(ls)
  names(temp)= c("p","d","q","P","D","Q","AIC","BIC","AICc")
  
  temp
  
}

##q=1,3 Q=1 , p=1,2, P=1,2 d=0,1 

output=SARIMA.c(p1=1,p2=3,q1=1,q2=4,P1=1,P2=3,Q1=1,Q2=2,d1=0,d2=1,data=res.fit)
output
```

Compare AIC

```{r, echo=FALSE,message=FALSE,warning=FALSE}
output[which.min(output$AIC),] 
```

Compare BIC

```{r, echo=FALSE,message=FALSE,warning=FALSE}
output[which.min(output$BIC),]
```

Compare AICc

```{r, echo=FALSE,message=FALSE,warning=FALSE}
output[which.min(output$AICc),]
```

Best models: ARIMA(2,0,0)x(0,1,1)\[12\] auto.arima suggested: ARIMA(2,0,1)(0,0,1)\[12\]

## Model Diagnostic

```{r, echo=FALSE,message=FALSE,warning=FALSE}
set.seed(1234)

model_output12 <- capture.output(sarima(res.fit, 2,0,0, 0,1,1,12)) 
```

```{r, echo=FALSE,message=FALSE,warning=FALSE}
cat(model_output12[33:65], model_output12[length(model_output12)], sep = "\n")
```

```{r, echo=FALSE,message=FALSE,warning=FALSE}
model_output13 <- capture.output(sarima(res.fit, 2,0,1, 0,0,1,12)) 
```

```{r, echo=FALSE,message=FALSE,warning=FALSE}
cat(model_output13[33:65], model_output13[length(model_output13)], sep = "\n")
```

ARIMA(2,0,0)x(0,1,1)\[12\] and ARIMA(2,0,1)(0,0,1)\[12\] both look okay.

## Using CV

```{r, echo=FALSE,message=FALSE,warning=FALSE}
n=length(res.fit)
k=24
 
 #n-k=220; 220/12=19;
 
rmse1 <- matrix(NA, 19,12)
rmse2 <- matrix(NA,19,12)
rmse3 <- matrix(NA,19,12)

st <- tsp(res.fit)[1]+(k-1)/12

for(i in 1:13)
{
  #xtrain <- window(a10, start=st+(i-k+1)/12, end=st+i/12)
  xtrain <- window(res.fit, end=st + i-1)
  xtest <- window(res.fit, start=st + (i-1) + 1/12, end=st + i)
  
  #ARIMA(0,1,1)x(0,1,1)[4] ARIMA(0,1,0)(2,0,0)[4]
  
  fit <- Arima(xtrain, order=c(2,0,0), seasonal=list(order=c(0,1,1), period=12),
                include.drift=TRUE, method="ML")
  fcast <- forecast(fit, h=12)
  
  fit2 <- Arima(xtrain, order=c(2,0,1), seasonal=list(order=c(0,0,1), period=12),
                include.drift=TRUE, method="ML")
  fcast2 <- forecast(fit2, h=12)
  
  fit3 <- Arima(xtrain, order=c(2,0,0), seasonal=list(order=c(1,1,0), period=12),
                include.drift=TRUE, method="ML")
  fcast3 <- forecast(fit3, h=12)
  

  rmse1[i,1:length(xtest)]  <- sqrt((fcast$mean-xtest)^2)
  rmse2[i,1:length(xtest)] <- sqrt((fcast2$mean-xtest)^2)
  rmse3[i,1:length(xtest)] <- sqrt((fcast3$mean-xtest)^2)
  
}

plot(1:12, colMeans(rmse1,na.rm=TRUE), type="l", col=2, xlab="horizon", ylab="RMSE")
lines(1:12, colMeans(rmse2,na.rm=TRUE), type="l",col=3)
lines(1:12, colMeans(rmse3,na.rm=TRUE), type="l",col=4)
legend("topleft",legend=c("fit1","fit2","fit3"),col=2:4,lty=1)
```

RMSE for ARIMA(2,0,0)x(0,1,1)\[12\] and ARIMA(2,0,1)(0,0,1)\[12\]

```{r, echo=FALSE,message=FALSE,warning=FALSE}
colMeans( rmse1,na.rm=TRUE)
```

```{r, echo=FALSE,message=FALSE,warning=FALSE}
colMeans( rmse2,na.rm=TRUE)
```

This fit is good: ARIMA(2,0,1)(0,0,1)\[12\]

Since this is the auto arima model we got from the previous step. We can see the summary.

```{r, echo=FALSE,message=FALSE,warning=FALSE}
xreg <- cbind(unrate = dd.ts[, "unrate"],
              psr = dd.ts[, "psr"])

fit <- Arima(dd$Births,order=c(2,0,1),seasonal = c(0,0,1),xreg=xreg)

summary(fit)
```

The equation will be y\[t\] = 11733.55 - 0.9303y\[t-1\] - 0.4590y\[t-2\] + 0.7073e\[t-1\] + 108.9109unrate\[t\] - 248.3602psr\[t\] + e\[t\] + 0.4858e\[t-12\]

## Forecasting (Using auto.arma())

```{r, echo=FALSE,message=FALSE,warning=FALSE}
unrate_fit<-auto.arima(dd$unrate)
funrate<-forecast(unrate_fit)
psr_fit<-auto.arima(dd$psr) #fiting an ARIMA model to the Import variable
fpsr<-forecast(psr_fit)

fxreg <- cbind(unrate = funrate$mean,
              psr = fpsr$mean)

fcast <- forecast(fit, xreg=fxreg) #fimp$mean gives the forecasted values
autoplot(fcast) + xlab("Year") +
  ylab("Births")
```

## Comments:

The auto arima generate the best model. The model create by myself also have a very good performace but it is not as good as the model from auto arima. The model has a seasonal component with a period of 12 (indicated by the \[12\] in the model specification), indicating monthly data. The model includes a regression component with two predictors, "unrate" and "psr", which were combined into the "xreg" variable using the cbind() function. The estimated coefficients for the ARIMA(2,0,1)(0,0,1)\[12\] model, which was automatically selected using the auto.arima() function, are provided along with their standard errors. The model has a residual standard deviation (sigma\^2) of 3279089 and the log likelihood is -2246.3. The model selection criteria, including AIC, AICc, and BIC, are also provided. Finally, the model's accuracy is evaluated on the training set using several error measures, including mean error (ME), root mean squared error (RMSE), mean absolute error (MAE), mean percentage error (MPE), mean absolute percentage error (MAPE), mean absolute scaled error (MASE), and autocorrelation of errors at lag 1 (ACF1).

# VAR

## Plotting the data

```{r, echo=FALSE,message=FALSE,warning=FALSE}
par(mfrow=c(3,1)) # plot the data
plot(dd$Births, main="Monthly Births", xlab="", ylab="") 
plot(dd$unrate, main="unrate", xlab="", ylab="")
plot(dd$psr, main="psr", xlab="", ylab="")
```

```{r, echo=FALSE,message=FALSE,warning=FALSE}
pairs(cbind(Birth=dd$Births, Unemployment=dd$unrate, PSR=dd$psr))
```

```{r, echo=FALSE,message=FALSE,warning=FALSE}
plot.ts(dd.ts[,2:4])
```

## Fitting a VAR model:

```{r, echo=FALSE,message=FALSE,warning=FALSE}
VARselect(dd[, c(2:4)], lag.max=10, type="both")
```

According to your VARselect results, the model with 4 lagged variables has the lowest AIC, HQ, and SC values, and the 3rd lowest FPE value. The model with 9 lagged variables has the lowest FPE value,

It's clear that according to selection criteria p=4 and 9 are good.

I'm fitting several models with p=1(for simplicity), 4, and 9.=\> VAR(1), VAR(4), VAR(9)

### VAR(1)

```{r, echo=FALSE,message=FALSE,warning=FALSE}
summary(VAR(dd[, c(2:4)], p=1, type='both'))
```

### VAR(4)

```{r, echo=FALSE,message=FALSE,warning=FALSE}
summary(VAR(dd[, c(2:4)], p=4, type='both'))
```

### VAR(9)

```{r, echo=FALSE,message=FALSE,warning=FALSE}
summary(VAR(dd[, c(2:4)], p=9, type='both'))
```

Some models have some variables significant but not all.

## CV

```{r}
n <- length(df$Births)
k <- 76 # 19 * 4

# n - k = 164; 164 / 4 = 41;
rmse1 <- matrix(NA, 240, 3)
rmse2 <- matrix(NA, 240, 3)
rmse3 <- matrix(NA, 41, 4)
year <- c()

# Convert data frame to time series object
ts_obj <- ts(df[, c("Births", "unrate", "psr")], start = decimal_date(as.Date("1994-01-01", format = "%Y-%m-%d")), frequency = 12)

st <- tsp(ts_obj)[1] + (k - 1) / 12

for (i in 1:45) {
  st <- st + 1/12 # update the end value for each iteration
  xtrain <- window(ts_obj, end = st)

  xtest <- window(ts_obj, start = st + 1/12, end = st + 3/12)

  fit <- VAR(xtrain, p = 5, type = "both")
  fcast <- predict(fit, n.ahead = 3)

  fbirths <- fcast$fcst$Births
  funrate <- fcast$fcst$unrate
  fpsr <- fcast$fcst$psr
  ff <- data.frame(fbirths[, 1], funrate[, 1], fpsr[, 1])

  year <- st

  ff <- ts(ff, start = c(year, 1), frequency = 12)

  a <- 3 * i - 2
  b <- 3 * i
  rmse1[c(a:b), ] <- sqrt((ff - xtest)^2)

  fit2 <- VAR(xtrain, p = 9, type = "both")
  fcast2 <- predict(fit2, n.ahead = 3)

  fbirths2 <- fcast2$fcst$Births
  funrate2 <- fcast2$fcst$unrate
  fpsr2 <- fcast2$fcst$psr
  ff2 <- data.frame(fbirths2[, 1], funrate2[, 1], fpsr2[, 1])

  year <- st

  ff2 <- ts(ff2, start = c(year, 1), frequency = 12)

  a <- 3 * i - 2
  b <- 3 * i
  rmse2[c(a:b), ] <- sqrt((ff2 - xtest)^2)
}

```

```{r}
n <- length(df$Births)
k <- 76 # 19 * 4

# n - k = 164; 164 / 4 = 41;
rmse1 <- matrix(NA, 240, 3)
rmse2 <- matrix(NA, 240, 3)
rmse3 <- matrix(NA, 41, 4)
year <- c()

# Convert data frame to time series object
ts_obj <- ts(df[, c("Births", "unrate", "psr")], start = decimal_date(as.Date("1994-01-01", format = "%Y-%m-%d")), frequency = 12)

st <- tsp(ts_obj)[1] + (k - 1) / 12

for (i in 1:45) {
  xtrain <- window(ts_obj, end = st + i - 1)
  xtest <- window(ts_obj, start = st + (i - 1) + 1 / 12, end = st + i)

  fit <- VAR(ts_obj, p = 5, type = "both")
  fcast <- predict(fit, n.ahead = 3)

  fbirths <- fcast$fcst$Births
  funrate <- fcast$fcst$unrate
  fpsr <- fcast$fcst$psr
  ff <- data.frame(fbirths[, 1], funrate[, 1], fpsr[, 1])

  year <- st + (i - 1) + 1 / 12

  ff <- ts(ff, start = c(year, 1), frequency = 12)

  a <- 3 * i - 2
  b <- 3 * i
  rmse1[c(a:b), ] <- sqrt((ff - xtest)^2)

  fit2 <- VAR(ts_obj, p = 9, type = "both")
  fcast2 <- predict(fit2, n.ahead = 3)

  fbirths2 <- fcast2$fcst$Births
  funrate2 <- fcast2$fcst$unrate
  fpsr2 <- fcast2$fcst$psr
  ff2 <- data.frame(fbirths2[, 1], funrate2[, 1], fpsr2[, 1])

  year <- st + (i - 1) + 1 / 12

  ff2 <- ts(ff2, start = c(year, 1), frequency = 12)

  a <- 3 * i - 2
  b <- 3 * i
  rmse2[c(a:b), ] <- sqrt((ff2 - xtest)^2)
}

yr <- rep(c(1994:2014), each = 12)
mnth <- rep(month.abb, 21)
rmse1 <- data.frame(yr, mnth, rmse1)
names(rmse1) <- c("Year", "Month", "Births", "unrate", "psr")
rmse2 <- data.frame(yr, mnth, rmse2)
names(rmse2) <- c("Year", "Month", "Births", "unrate", "psr")

ggplot() +
  geom_line(data = rmse1, aes(x = Year, y = Births), color = "blue") +
  geom_line(data = rmse2, aes(x = Year, y = Births), color = "red") +
  labs(
    title = "CV RMSE for Monthly Births

```

```{r, echo=FALSE,message=FALSE,warning=FALSE}
n=length(dd$Births)
k=24 #19*4

#n-k=220; 220/12=19;

rmse1 <- matrix(NA, 19,12)
rmse2 <- matrix(NA, 19,12)
rmse3 <- matrix(NA,19,12)
year<-c()

# Convert data frame to time series object
ts_obj <- ts(dd[, c(2:4)], star=decimal_date(as.Date("1994-01-01",format = "%Y-%m-%d")),frequency = 12)

st <- tsp(ts_obj )[1]+(k-1)/12


for(i in 1:19)
{
  
  xtrain <- window(ts_obj, end=st + i-1)
  xtest <- window(ts_obj, start=st + (i-1) + 1/12, end=st + i)
  
  
  fit <- VAR(ts_obj, p=1, type='both')
  fcast <- predict(fit, n.ahead = 12)
  
  fbirth<-fcast2$fcst$Births
  funrate<-fcast2$fcst$unrate
  fpsr<-fcast2$fcst$psr
  ff<-data.frame(fbirth[,1],funrate[,1],fpsr[,1])
  
  year<-st + (i-1) + 1/12
  
  ff<-ts(ff,start=c(year,1),frequency = 12)
  
  a = 4*i-3
  b= 4*i
  rmse1[c(a:b),]  <-sqrt((ff-xtest)^2)
  
  fit2 <- VAR(ts_obj, p=9, type='both')
  fcast2 <- predict(fit2, n.ahead = 4)
  
  fbirth<-fcast2$fcst$Births
  funrate<-fcast2$fcst$unrate
  fpsr<-fcast2$fcst$psr
  ff2<-data.frame(fbirth[,1],funrate[,1],fpsr[,1])
  
  year<-st + (i-1) + 1/4
  
  ff2<-ts(ff2,start=c(year,1),frequency = 4)
  
  a = 12*i-3
  b= 12*i
  rmse2[c(a:b),]  <-sqrt((ff2-xtest)^2)
}

yr = rep(c(1978:2022),each =4)
qr = rep(paste0("Q",1:4),45)

rmse1 = data.frame(yr,qr,rmse1)
names(rmse1) =c("Year", "Quater","GDP","Employment","PIncome")
rmse2 = data.frame(yr,qr,rmse2)
names(rmse2) =c("Year", "Quater","GDP","Employment","PIncome")

ggplot() + 
  geom_line(data = rmse1, aes(x = Year, y = GDP),color = "blue") +
  geom_line(data = rmse2, aes(x = Year, y = GDP),color = "red") +
  labs(
    title = "CV RMSE for GDP",
    x = "Date",
    y = "RMSE",
    guides(colour=guide_legend(title="Fit")))
```

```{r, echo=FALSE,message=FALSE,warning=FALSE}
```

```{r, echo=FALSE,message=FALSE,warning=FALSE}
```
